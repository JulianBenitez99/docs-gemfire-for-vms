<a id="JTA_transactions_with_GemFire"></a>

# JTA Global Transactions with <span class="keyword">GemFire</span>

Use JTA global transactions to coordinate <span class="keyword">GemFire</span> cache transactions and JDBC transactions.

JTA is a standard Java interface you can use to coordinate <span class="keyword">GemFire</span> cache transactions and JDBC transactions globally under one umbrella. JTA provides direct coordination between the <span class="keyword">GemFire</span> cache and another transactional resource, such as a database. The parties involved in a JTA transaction include:

-   The Java application, responsible for starting the global transaction
-   The JTA transaction manager, responsible for opening, committing, and rolling back transactions
-   The transaction resource managers, including the <span class="keyword">GemFire</span> cache transaction manager and the JDBC resource manager, responsible for managing operations in the cache and database respectively

Using JTA, your application controls all transactions in the same standard way, whether the transactions act on the <span class="keyword">GemFire</span> cache, a JDBC resource, or both together. When a JTA global transaction is done, the <span class="keyword">GemFire</span> transaction and the database transaction are both complete.

When using JTA global transactions with <span class="keyword">GemFire</span>, you have three options:

1.  Coordinate with an external JTA transaction manager in a container (such as WebLogic or JBoss)
2.  Set <span class="keyword">GemFire</span> as the “last resource” while using a container (such as WebLogic or JBoss) as the JTA transaction manager
3.  Have <span class="keyword">GemFire</span> act as the JTA transaction manager

An application creates a global transaction by using `javax.transaction.UserTransaction` bound to the JNDI context `java:/UserTransaction` to start and terminate transactions. During the transaction, cache operations are done through <span class="keyword">GemFire</span> as usual as described in [GemFire Cache Transactions](cache_transactions.html#topic_e15_mr3_5k).

**Note:**
See the Sun documentation for more information on topics such as JTA, `javax.transaction`, committing and rolling back global transactions, and the related exceptions.

-   **[Coordinating with External JTA Transactions Managers](../../../latest/developing/transactions/JTA_transactions.html#concept_cp1_zx1_wk)**

    <span class="keyword">GemFire</span> can work with the JTA transaction managers of several containers like JBoss, WebLogic, GlassFish, and so on.

-   **[Using GemFire as the "Last Resource" in a Container-Managed JTA Transaction](../../../latest/developing/transactions/JTA_transactions.html#concept_csy_vfb_wk)**

    The "last resource" feature in certain 3rd party containers such as WebLogic allow the use one non-XAResource (such as <span class="keyword">GemFire</span>) in a transaction with multiple XAResources while ensuring consistency.

-   **[Using GemFire as the JTA Transaction Manager](../../../latest/developing/transactions/JTA_transactions.html#concept_8567sdkbigige)**

    You can also use <span class="keyword">GemFire</span> as the JTA transaction manager.

-   **[Behavior of GemFire Cache Writers and Loaders Under JTA](../../../latest/developing/transactions/cache_plugins_with_jta.html)**

    When <span class="keyword">GemFire</span> participates in a global transactions, you can still have <span class="keyword">GemFire</span> cache writers and cache loaders operating in the usual way.

-   **[Turning Off JTA Transactions](../../../latest/developing/transactions/turning_off_jta.html)**

    You can configure regions to not participate in any JTA global transaction.

# Coordinating with External JTA Transactions Managers

<span class="keyword">GemFire</span> can work with the JTA transaction managers of several containers like JBoss, WebLogic, GlassFish, and so on.

At startup <span class="keyword">GemFire</span> looks for a TransactionManager (`javax.transaction.TransactionManager`) that has been bound to its JNDI context. When <span class="keyword">GemFire</span> finds such an external transaction manager, all <span class="keyword">GemFire</span> region operations (such as get and put) will participate in global transactions hosted by this external JTA transaction manager.

This figure shows the high-level operation of a JTA global transaction whose resources include a <span class="keyword">GemFire</span> cache and a database.

<img src="../../images/transactions_jta_app_server.png" id="concept_cp1_zx1_wk__image_C2935E48415349659FC39BF5C7E75579" class="image" />

An externally coordinated JTA global transaction is run in the following manner:

1.  Each region operation looks up for presence of a global transaction. If one is detected, then a <span class="keyword">GemFire</span> transaction is started automatically, and we register a `javax.transaction.Synchronization` callback with the external JTA transaction manager.
2.  At transaction commit, <span class="keyword">GemFire</span> gets a `beforeCommit()` callback from the external JTA transaction manager. <span class="keyword">GemFire</span> does all locking and conflict detection at this time. If this fails, an exception is thrown back to JTA transaction manager, which then aborts the transaction.
3.  After a successful `beforeCommit()`callback, JTA transaction manager asks other data sources to commit their transaction.
4.  <span class="keyword">GemFire</span> then gets a `afterCommit()` callback in which changes are applied to the cache and distributed to other members.

You can disable JTA in any region that should not participate in JTA transactions. See [Turning Off JTA Transactions](turning_off_jta.html#concept_nw2_5gs_xk).

-   **[How to Run a JTA Transaction Coordinated by an External Transaction Manager](../../../latest/developing/transactions/JTA_transactions.html#task_j3g_3mn_1l)**

    Use the following procedure to run a <span class="keyword">GemFire</span> global JTA transaction coordinated by an external JTA transaction manager.

<a id="task_j3g_3mn_1l"></a>

## How to Run a JTA Transaction Coordinated by an External Transaction Manager

Use the following procedure to run a <span class="keyword">GemFire</span> global JTA transaction coordinated by an external JTA transaction manager.

1.  **Configure the external data sources in the external container.** Do not configure the data sources in cache.xml . They are not guaranteed to get bound to the JNDI tree.
2.  

    Configure <span class="keyword">GemFire</span> for any necessary transactional behavior in the `cache.xml` file. For example, enable `copy-on-read` and specify a transaction listener, as needed. See [Setting Global Copy on Read](working_with_transactions.html#concept_vx2_gs4_5k) and [Configuring Transaction Plug-In Event Handlers](working_with_transactions.html#concept_ocw_vf1_wk) for details. 
3.  

    Make sure that JTA transactions are enabled for the regions that will participate in the transaction. See [Turning Off JTA Transactions](turning_off_jta.html#concept_nw2_5gs_xk) for details. 
4.  

     Start the transaction through the external container. 
5.  

    Initialize the <span class="keyword">GemFire</span> cache. <span class="keyword">GemFire</span> will automatically join the transaction. 
6.  

     Execute operations in the cache and the database as usual. 
7.  

     Commit the transaction through the external container. 

# Using <span class="keyword">GemFire</span> as the "Last Resource" in a Container-Managed JTA Transaction

The "last resource" feature in certain 3rd party containers such as WebLogic allow the use one non-XAResource (such as <span class="keyword">GemFire</span>) in a transaction with multiple XAResources while ensuring consistency.

In the previous two JTA transaction use cases, if the <span class="keyword">GemFire</span> member fails after the other data sources commit but before <span class="keyword">GemFire</span> receives the `afterCommit` callback, <span class="keyword">GemFire</span> and the other data sources may become inconsistent. To prevent this from occurring, you can use the container's "last resource optimization" feature, with <span class="keyword">GemFire</span> set as the "last resource". Using <span class="keyword">GemFire</span> as the last resource ensures that in the event of failure, <span class="keyword">GemFire</span> remains consistent with the other XAResources involved in the transaction.

To accomplish this, the application server container must use a JCA Resource Adapter to accomodate <span class="keyword">GemFire</span> as the transaction's last resource. The transaction manager of the container first issues a "prepare" message to the participating XAResources. If the XAResources all accept the transaction, then the manager issues a "commit" instruction to the non-XAResource (in this case, <span class="keyword">GemFire</span>). The non-XAResource (in this case, <span class="keyword">GemFire</span>) participates as a local transaction resource. If the non-XAResource fails, then the transaction manager can rollback the XAResources.

<img src="../../images/transactions_jca_adapter.png" id="concept_csy_vfb_wk__image_opb_sgb_wk" class="image" />

-   **[How to Run JTA Transactions with GemFire as a "Last Resource"](../../../latest/developing/transactions/JTA_transactions.html#task_sln_x3b_wk)**

<a id="task_sln_x3b_wk"></a>

# How to Run JTA Transactions with <span class="keyword">GemFire</span> as a "Last Resource"

1.  Locate the `$GEMFIRE/lib/gemfire-jca.rar` file in your <span class="keyword">GemFire</span> installation. 
2.  Add your container-specific XML file to the `gemfire-jca.rar` file. 
    1.  Create a container-specific resource adapter XML file named &lt;container&gt;-ra.xml. For example, an XML file for a WebLogic resource adapter XML file might look something like this:
        ``` pre
        <?xml version="1.0"?>
        <!DOCTYPE weblogic-connection-factory-dd PUBLIC '-//BEA Systems, Inc.//DTD WebLogic 9.0.0 Connector//EN' 
        'http://www.bea.com/servers/wls810/dtd/weblogic810-ra.dtd'>

        <weblogic-connection-factory-dd>
           <connection-factory-name>GFE JCA</connection-factory-name>
           <jndi-name>gfe/jca</jndi-name>
        </weblogic-connection-factory-dd>
        ```

    2.  Create a folder named `META-INF`, and place the container-specific XML file inside the directory. For example, the folder structure would look like this:
        ``` pre
        META-INF/weblogic-ra.xml
        ```

    3.  Navigate to the directory above the `META-INF` folder and execute the following command:
        ``` pre
        $ jar -uf <GEMFIRE_INSTALL_DIR>/lib/gemfire-jca.rar META-INF/weblogic-ra.xml
        ```

3.  Make sure that `$GEMFIRE/lib/gemfire.jar` is accessible in the CLASSPATH of the JTA transaction coordinator container.
4.  Deploy `gemfire-jca.rar` file on the JTA transaction coordinator container . When deploying the file, you specify the JNDI name and so on. 
5.  Configure <span class="keyword">GemFire</span> for any necessary transactional behavior. Enable `copy-on-read` and specify a transaction listener, if you need one. See [Setting Global Copy on Read](working_with_transactions.html#concept_vx2_gs4_5k) and [Configuring Transaction Plug-In Event Handlers](working_with_transactions.html#concept_ocw_vf1_wk) for details.
6.  Get an initial context through `com.gemstone.cache.Cache.getJNDIContext`. For example:
    ``` pre
    Context ctx = cache.getJNDIContext();
    ```

    This returns `javax.naming.Context` and gives you the JNDI associated with the cache. The context contains the `TransactionManager`, `UserTransaction`, and any configured JDBC resource manager.

7.  Start and commit the global transaction using the `UserTransaction` object rather than with <span class="keyword">GemFire</span>'s `CacheTransactionManager`. 
    ``` pre
    UserTransaction txManager = (UserTransaction)ctx.lookup("java:/UserTransaction");
    ```

8.  Obtain a <span class="keyword">GemFire</span> connection.
    ``` pre
    GFConnectionFactory cf = (GFConnectionFactory) ctx.lookup("gfe/jca");

    //This step of obtaining connection is what begins the
    //LocalTransaction.
    //If this is absent, GFE operations will not be part of any
    //transaction
    GFConnection gemfireConn = (GFConnection)cf.getConnection();
    ```

See [JCA Resource Adapter Example](jca_adapter_example.html#concept_swv_z2p_wk) for an example of how to set up a transaction using the JCA Resource Adapter.

## Using <span class="keyword">GemFire</span> as the JTA Transaction Manager

You can also use <span class="keyword">GemFire</span> as the JTA transaction manager.

<span class="keyword">GemFire</span> ships with its own implementation of a JTA transaction manager. However, note that this implementation is not XA-compliant; therefore, it does not persist any state, which could lead to an inconsistent state after recovering a crashed member.

<img src="../../images/transactions_jta.png" id="concept_8567sdkbigige__image_C8D94070E55F4BCC8B5FF3D5BEBA99ED" class="image" />

The <span class="keyword">GemFire</span> JTA transaction manager is initialized when the <span class="keyword">GemFire</span> cache is initialized. Until then, JTA is not available for use. The application starts a JTA transaction by using the `UserTransaction.begin` method. The `UserTransaction` object is the application’s handle to instruct the JTA transaction manager on what to do.

The <span class="keyword">GemFire</span> JTA implementation also supports the J2EE Connector Architecture (JCA) `ManagedConnectionFactory`.

The <span class="keyword">GemFire</span> implementation of JTA has the following limitations:

-   Only one JDBC database instance per transaction is allowed, although you can have multiple connections to that database.
-   Multiple threads cannot participate in a transaction.
-   Transaction recovery after a crash is not supported.

In addition, JTA transactions are subject to the limitations of <span class="keyword">GemFire</span> cache transactions such as not being supported on regions with global scope. When a global transaction needs to access the <span class="keyword">GemFire</span> cache, JTA silently starts a <span class="keyword">GemFire</span> cache transaction.

-   **[How to Run a JTA Global Transaction Using GemFire as the JTA Transaction Manager](../../../latest/developing/transactions/JTA_transactions.html#task_qjv_khb_wk)**

    This topic describes how to run a JTA global transaction in <span class="keyword">GemFire</span> .

<a id="task_qjv_khb_wk"></a>

# How to Run a JTA Global Transaction Using <span class="keyword">GemFire</span> as the JTA Transaction Manager

This topic describes how to run a JTA global transaction in <span class="keyword">GemFire</span> .

To run a global transaction, perform the following steps:

1.  

    Configure the external data sources in the `cache.xml` file. See [Configuring Database Connections Using JNDI](configuring_db_connections_using_JNDI.html#topic_A5E3A67C808D48C08E1F0DC167C5C494) for examples. 
2.  

    Include the JAR file for any data sources in your CLASSPATH. 
3.  

    Configure <span class="keyword">GemFire</span> for any necessary transactional behavior. Enable `copy-on-read` for your cache and specify a transaction listener, if you need one. See [Setting Global Copy on Read](working_with_transactions.html#concept_vx2_gs4_5k) and [Configuring Transaction Plug-In Event Handlers](working_with_transactions.html#concept_ocw_vf1_wk) for details. 
4.  

    Make sure that JTA transactions are not disabled in the `cache.xml` file or the application code. 
5.  

    Initialize the <span class="keyword">GemFire</span> cache. 
6.  

    Get an initial context through `com.gemstone.gemfire.cache.Cache.getJNDIContext`. For example: 
    ``` pre
    Context ctx = cache.getJNDIContext();
    ```

    This returns `javax.naming.Context` and gives you the JNDI associated with the cache. The context contains the `TransactionManager`, `UserTransaction`, and any configured JDBC resource manager.

7.  

    Look up the `UserTransaction` context: 
    ``` pre
    UserTransaction txManager = (UserTransaction) ctx.lookup("java:/UserTransaction");
    ```

    With `UserTransaction`, you can begin, commit, and rollback transactions.
    If a global transaction exists when you use the cache, it automatically joins the transaction. Operations on a region automatically detect and become associated with the existing global transaction through JTA synchronization. If the global transaction has been marked for rollback, however, the <span class="keyword">GemFire</span> cache is not allowed to enlist with that transaction. Any cache operation that causes an attempt to enlist throws a `FailedSynchronizationException`.

    The <span class="keyword">GemFire</span> cache transaction’s commit or rollback is triggered when the global transaction commits or rolls back. When the global transaction is committed using the `UserTransaction` interface, the transactions of any registered JTA resources are committed, including the <span class="keyword">GemFire</span> cache transaction. If the cache or database transaction fails to commit, the `UserTransaction` call throws a `TransactionRolledBackException`. If a commit or rollback is attempted directly on a <span class="keyword">GemFire</span> transaction that is registered with JTA, that action throws an `IllegalStateException`.

See [GemFire JTA Transaction Example](transaction_jta_gemfire_example.html#concept_ffg_sj5_1l).

-   **[Configuring Database Connections Using JNDI](../../../latest/developing/transactions/configuring_db_connections_using_JNDI.html)**

-   **[Example DataSource Configurations in cache.xml](../../../latest/developing/transactions/configuring_db_connections_using_JNDI.html#topic_F67EC20067124A618A8099AB4CBF634C)**


