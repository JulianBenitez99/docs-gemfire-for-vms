---
title:  Using C++ Enum Type with PDX Serialization
---

Because there is no "object" base type in C++, enums cannot be directly passed as a parameter to the `writeObject` and `readObject` API.

To use the C++ enum type with PDX serialization, you will have to wrap the `enum` in the `CacheableEnum` class type by specifying classname, enumname and ordinal.

``` pre
enum enumQuerytest { id1, id2, id3 };
 class TESTOBJECT_EXPORT PdxEnumTestClass :public PdxSerializable
  {
  private:
    int m_id;
    CacheableEnumPtr m_enumid;

  public:
    int getID(){
      return m_id;
    }

    CacheableEnumPtr getEnumID() {
      return m_enumid;
    }

    PdxEnumTestClass(int id)
    {
      m_id = id;
      switch (m_id) {
        case 0:
          m_enumid = CacheableEnum::create("enumQuerytest", "id1", id1);
          break;
        case 1:
          m_enumid = CacheableEnum::create("enumQuerytest", "id2", id2);
          break;
        case 2:
          m_enumid = CacheableEnum::create("enumQuerytest", "id3", id3);
          break;
        default:
          m_enumid = CacheableEnum::create("enumQuerytest", "id1", id1);
          break;
      }
    }

    PdxEnumTestClass() { }

    void toData(PdxWriterPtr pw) {
      pw->writeInt("m_id", m_id);
      pw->writeObject("m_enumid", m_enumid);
    }

    void fromData(PdxReaderPtr pr) {
      m_id = pr->readInt("m_id");
      m_enumid = pr->readObject("m_enumid");
    }

    CacheableStringPtr toString() const {
      return CacheableString::create("PdxEnumTestClass");
    }

    char* GetClassName() const {
      return "com.example.PdxEnumTestClass";
    }

    static PdxSerializable* createDeserializable() {
      return new PdxEnumTestClass();
    }
  };
```

<a id="concept_F38FDBC327204B4EB1E0BC74B4C95409__section_3491F76DB8C0464D89418B89372BBAEA"></a>
## How Put and Queries Work on Enum

The following code sample demonstrates how put and query operations work when using the C++ enum Type with PDX serialization:

``` pre
//Creating objects of type PdxEnumTestClass
PdxEnumTestClassPtr pdxobj1(new PdxEnumTestClass(0));
PdxEnumTestClassPtr pdxobj2(new PdxEnumTestClass(1));
PdxEnumTestClassPtr pdxobj3(new PdxEnumTestClass(2));

RegionPtr rptr = getHelper()->getRegion( "DistRegionAck" );

//PUT Operations
rptr->put( CacheableInt32::create(0), pdxobj1 );
LOG( "pdxPut 1 completed " );

rptr->put( CacheableInt32::create(1), pdxobj2 );
LOG( "pdxPut 2 completed " );

rptr->put( CacheableInt32::create(2), pdxobj3 );
LOG( "pdxPut 3 completed " );


//Query
try {
    Serializable::registerPdxType(PdxEnumTestClass::createDeserializable);
    LOG("PdxEnumTestClass Registered Successfully....");
} catch (gemfire::IllegalStateException&/* ex*/) {
    LOG("PdxEnumTestClass IllegalStateException");
}

RegionPtr rptr = getHelper()->getRegion( "DistRegionAck" );
SelectResultsPtr results = rptr->query("m_enumid.name = 'id2'");  
ResultSetPtr rsptr = dynCast<ResultSetPtr>(results);
SelectResultsIterator iter = rsptr->getIterator();  
while (iter.moveNext()) {
    PdxEnumTestClassPtr re = dynCast<PdxEnumTestClassPtr>(iter.current());
}    
```


