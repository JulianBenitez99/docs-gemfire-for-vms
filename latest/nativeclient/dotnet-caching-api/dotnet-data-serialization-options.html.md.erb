---
title:  Data Serialization Options
---

Built-in .NET types are serialized automatically into the cache and can be retrieved by Java servers and other <span class="keyword">Geode</span> clients. For domain objects that are not simple types, you have three <span class="keyword">Geode</span> serialization options.

The options give good performance and flexibility for data storage, transfers, and language types. The <span class="keyword">Geode</span> options can also improve performance in serializing and deserializing built-in types.

The simplest option is to use perform automatic serialization by registering the <span class="keyword">Geode</span> .NET PDX reflection-based autoserializer in your application. When you have this registered, <span class="keyword">Geode</span> uses it for all domain objects that are not custom serialized.

You can also custom serialize your objects by implementing one of the <span class="keyword">Geode</span> .NET interfaces, `GemStone::GemFire::Cache::Generic::IPdxSerializable` or `GemStone::GemFire::Cache::IGFSerializable`.

You also have the option of using default .NET serialization, but you cannot use it unless you also use helper classes. The helper classes you must use are `CacheableObject` and `CacheableObjectXml`.

<span class="keyword">Geode</span> .NET PDX serialization has more bytes in overhead than <span class="keyword">Geode</span> .NET Data serialization, but using PDX serialization helps you avoid the performance costs of deserialization when performing queries. Applications can use `PdxInstances` in functions to avoid the deserialization of entire objects.

<a id="concept_6DC3DD288F6C4190AEA07DEDE76DD867__table_D61A94C4BFBE4712835F632F30BB488E"></a>

<table>
<caption><span class="tablecap">Table 1. Serialization Options—Comparison of Features</span></caption>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead>
<tr class="header">
<th>Capability</th>
<th>IGFSerializable</th>
<th>IPdxSerializable and PDX reflection-based autoserializer</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Handles multiple versions of domain objects*</p></td>
<td></td>
<td>X</td>
</tr>
<tr class="even">
<td><p>Provides single field access on servers of serialized data, without full deserialization. Supported also for OQL queries.</p></td>
<td></td>
<td>X</td>
</tr>
<tr class="odd">
<td><p>Automatically ported to other languages by <span class="keyword">Geode</span> - no need to program Java-side implementation</p></td>
<td></td>
<td>X</td>
</tr>
<tr class="even">
<td><p>Works with <span class="keyword">Geode</span> delta propagation</p></td>
<td>X</td>
<td>X (See explanation below.)</td>
</tr>
</tbody>
</table>

: <span class="tablecap">Table 1. Serialization Options—Comparison of Features</span>

\*You can mix domain object versions where the differences between versions are the addition and removal of object fields.

By default, you can use <span class="keyword">Geode</span> delta propagation with PDX serialization. However, delta propagation will not work if you have set the <span class="keyword">Geode</span> property read-serialized to "true". In terms of deserialization, to apply a change delta propagation requires a domain class instance and the `fromDelta` method. If you have set read-serialized to true, you will receive an `IPdxInstance` instead of a domain class instance and `IPdxInstance` does not have the `fromDelta` method required for delta propagation. You will also require the Java domain class on the server similar to the you would need the .NET PDX Delta domain class.

For detailed information on the interfaces, see the online API documentation.


