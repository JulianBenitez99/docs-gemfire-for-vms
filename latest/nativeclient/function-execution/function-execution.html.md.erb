---
title:  Function Execution
---

*Function Execution* describes how you can execute application functions to achieve linear scalability. It explains how function execution works and lists specific use cases.

**Note:**
Function execution can be used only along with the pool functionality. For more information about the pool API, see [Using Connection Pools](../connection-pools/connection-pools.html#using-connection-pools). Only C++ versions of Function Execution API interfaces, classes, and methods (like `FunctionService::onRegion`) are shown in text. The code examples show C++ and C\#.

-   **[Understanding Data-Aware Function Routing](../../nativeclient/function-execution/data-aware-function-execution.html)**

    Achieving linear scalability is predicated upon being able to horizontally partition the application data such that concurrent operations by distributed applications can be done independently across partitions.

-   **[How Functions Execute](../../nativeclient/function-execution/how-functions-execute.html)**

    This section discusses the basic function execution process, how highly available functions execute after a failure, and the execution scenarios for data-dependent and data-independent functions.

-   **[Executing Functions](../../nativeclient/function-execution/executing-functions.html)**

    Using the <span class="keyword">Geode</span> function execution service, you can execute application functions on a single server member, in parallel on a subset of server members, or in parallel on all server members of a distributed system.


