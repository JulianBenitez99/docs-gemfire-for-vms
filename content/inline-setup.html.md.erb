---
title: Setting Up Servers for an Inline Cache
---

See [The Inline Cache](design-patterns.html#inline-cache)
for an introductory description of an inline cache.
The implementation of an inline cache
requires custom code deployed on the GemFire servers
to interact with the backend data store for read misses
and for writes.

The custom code always implements a cache loader for read misses.
The custom code and configuration setup differs for writes.
A write behind implementation uses an asynchronous event queue (AEQ)
and an AEQ listener.
A write through implementation uses a cache writer.

## <a id="inline-cache-loader"></a> Implement a Cache Loader for Read Misses

An app's get operation is a cache read.
If the desired entry is in the region, it is a cache hit,
and the value is returned to the app.
If the desired entry is not in the region, it is a cache miss.
Implement and deploy a thread-safe `CacheLoader` interface on the servers;
see the [Pivotal GemFire API Documentation](http://gemfire-apis.docs.pivotal.io/) for details.
A miss invokes the `CacheLoader.load` method.
The `CacheLoader.load` method must acquire and return the value
for the specified key.
For an inline cache, that value is acquired from the backend data store.

![inline read misses](inline-read.png)

The value returned from the `CacheLoader.load` method
will be put into the region and then returned to the waiting app,
completing the app's get operation.
Since the app blocks while waiting for the result of the get operation,
design the `CacheLoader.load` method to acquire the value
as quickly as possible.

The `CacheLoader.load` method
queries the backend data store for the desired entry.
That communication between the server process and the backend
data store requires a connection,
and establishing a connection is likely to use a set of
credentials.
Implement the `CacheLoader.initialize` method to establish the
connection.

Specify the credentials during configuration with the gfsh `create region`
command.
Add the JSON description to the `--cache-loader` option.
The credentials will be passed as parameters to the
`CacheLoader.initialize` method during `CacheLoader` instance
construction.


## <a id="inline-cache-AEQ"></a> Implement an Asynchronous Event Queue and Cache Listener for Write Behind

An app's put operation is a cache write.
For a write behind implementation,
the value is placed into the region,
and it will also be asynchronously written to the backend data store,
allowing the app's write operation to complete without waiting
for the backend data store write to complete.

An asynchronous event queue (AEQ) to queue the write events together with 
an implementation of the `AsyncEventListener` interface
provides the desired behavior.
See the [Pivotal GemFire API Documentation](http://gemfire-apis.docs.pivotal.io/) for details.


![inline cache server interactions](inline-WB.png)

With a configured AEQ,
all put operations first create or update the entry
in the hosted region on the server and then add the event to the AEQ.

The `AsyncEventListener.processEvents` method's task is expected to
iterate through the AEQ,
writing each newly created or updated entry in the AEQ
to the backend data store.
For each write event, `processEvents` writes to the backend data store.
The `AsyncEventListener.processEvents` method is invoked
when either the AEQ holds a configured quantity of events,
or a configured quantity of time that has elapsed
since the earliest entry entered the AEQ. 

The communication between the server process and the backend
data store to do the writes requires a connection,
and establishing a connection is likely to use a set of
credentials.
Implement the `AsyncEventListener.initialize` method to establish the
connection.

Specify the credentials in the gfsh `create async-event-queue` command
during configuration with the `--listener-param` option.
The credentials will be passed as parameters to the
`AsyncEventListener.initialize` method during `AsyncEventListener`
instance construction.

Configure the AEQ to be persistent, such that it does not lose queued
backend data store writes across unexpected server restarts.

## <a id="inline-cache-writer"></a> Implement a Cache Writer for Write Through

An app's put operation is a cache write.
For a write through implementation,
the value will be written to the backend data store
prior to being placed into the region.
After both writes, the app's put operation completes.

A thread-safe `CacheWriter` interface implementation provides
the correct behavior for write through.
See the [Pivotal GemFire API Documentation](http://gemfire-apis.docs.pivotal.io/) for details.
Implement the `CacheWriter.beforeCreate` method to
handle backend data store writes for put operations that add
a new entry to the region.
Implement the `CacheWriter.beforeUpdate` method to
handle backend data store writes for put operations that modify
an existing entry in the region.
An implementation of `CacheWriter.beforeDestroy` may be appropriate
to handle an update of the backend data store for a region
operation that removes an entry.

![inline cache server interactions](inline-WT.png)

Communication between the server process and the backend
data store to do the writes requires a connection,
and establishing a connection is likely to use a set of
credentials.
Implement the `CacheWriter.initialize` method to establish the
connection.

Specify the credentials in the gfsh `create region` command
during configuration.
Add the JSON description to the `--cache-writer` option.
The credentials will be passed as parameters to the
`CacheWriter.initialize` method during `CacheWriter` instance
construction.

## <a id="inline-configure-WB"></a> Configure Using gfsh for Write Behind

1. Follow the directions in [Connect with gfsh over HTTPS](accessing-instance.html#gfsh-connect-https) to connect to the cluster
with the cluster operator credentials from the service key.

1. Deploy the cache loader and the AEQ listener
code to the servers within the PCC service instance:

    ```
    gfsh>deploy --jars=/path/to/MyLoader.jar,/path/to/MyListener.jar
    ```

1. Create the AEQ, assigning a name for the AEQ
(called `WB-AEQ` in this example), specifying the AEQ listener,
and specifying the AEQ listener's parameters:

    ```
    gfsh>create async-event-queue --id=WB-AEQ \
      --parallel=true --persistent \
      --listener=com.myCompany.MyListener \
      --listener-param=url#jdbc:db2:SAMPLE,username#admin,password#gobbledeegook
    ```
    The persistence of the AEQ uses the default disk store,
    since no disk store is specified in this command.

1. Create the region, specifying the cache loader, the AEQ listener,
and the assigned AEQ name.

    ```
    gfsh>create region --name=myRegion --type=PARTITION_REDUNDANT \
      --cache-loader=com.myCompany.MyLoader{'url':'jdbc:db2:SAMPLE','username':'admin',password:'gobbledeegook'}
      --cache-listener=com.myCompany.MyListener
      --async-event-queue-id=WB-AEQ

## <a id="inline-configure-WT"></a> Configure Using gfsh for Write Through

1. Follow the directions in [Connect with gfsh over HTTPS](accessing-instance.html#gfsh-connect-https) to connect to the cluster
with the cluster operator credentials from the service key.

1. Deploy the cache loader and the cache writer
code to the servers within the PCC service instance:

    ```
    gfsh>deploy --jars=/path/to/MyLoader.jar,/path/to/MyWriter.jar
    ```

1. Create the region, specifying the cache loader and the cache
writer:

    ```
    gfsh>create region --name=myRegion --type=PARTITION_REDUNDANT \
      --cache-loader=com.myCompany.MyLoader{'url':'jdbc:db2:SAMPLE','username':'admin',password:'gobbledeegook'}
      --cache-writer=com.myCompany.MyWriter{'url':'jdbc:db2:SAMPLE','username':'admin',password:'gobbledeegook'}

